# 数据结构

## 堆 heap

堆就是用数组实现的二叉树，所有它没有使用父指针或者子指针。堆根据 “堆属性” 来排序，“堆属性” 决定了树中节点的位置。

堆的常用方法：

- 构建优先队列
- 支持堆排序
- 快速找出一个集合中的最小值（或者最大值）

堆分为两种：最大堆和最小堆，两者的差别在于节点的排序方式。

在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的 “堆属性”，并且这个属性对堆中的每一个节点都成立。

## 链表 linked list

> 一种线性表，但是并不会按线性的顺序存储数据, 而是在每一个节点里存到下一个节点的指针 (Pointer). 主要分为三种: 单向链表, 双向链表, 循环链表.

## 树

> [博客](https://www.cnblogs.com/maybe2030/p/4732377.html)
> [参考简书](https://www.jianshu.com/p/45661b029292)

1. 深度和高度 (层数): 深度为根到最深子节点的节点个数, `height = depth - 1`
2. 二叉树
3. 完全二叉树
   1. 若设二叉树的深度为 h，除第 h 层外，其它各层 (1～(h-1) 层) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。
   2. 堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra 算法、Prim 算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。
4. 满二叉树
   1. 叶子数为 2^h, 如只有一层根节点 (d=1, h=0)
   2. 第 k 层的节点数为 2^(k-1)
   3. 总节点数为
5. 二叉搜索树
   1. 树中每个节点最多有两个子树，通常称为左子树和右子树
   2. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
   3. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
   4. 它的左右子树仍然是一棵二叉搜索树 (recursive)
   5. 中序遍历: 当到达某个节点时，先访问左子节点，再输出该节点，最后访问右子节点。
   6. 前序遍历: 当到达某个节点时，先输出该节点，再访问左子节点，最后访问右子节点。
   7. 后序遍历: 当到达某个节点时，先访问左子节点，再访问右子节点，最后输出该节点。
   8. 搜索, 插入, 删除,排序
6. 平衡树 (二叉树的一种)

   判定是否为平衡树的条件：将该树重新排序，若不存在重新排序后的二叉树的树高比原来的树小，则判定该树为平衡树。其实就是判断 `2^(height+1)-1 > nodeCount > 2^height -1`
7. [B 树](jianshu.com/p/75b062bffefb)

## 哈希表 hashtable
> 参考 https://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html

